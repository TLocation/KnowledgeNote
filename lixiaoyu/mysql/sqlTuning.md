# mysql调优

```
MySql 在执行查询的时候一般情况下 只会用到一个索引 一条sql有多个索引的情况（由优化器来判断该用哪个比较快）
```

## 性能分析思路
>1.首先需要使用【慢查询日志】功能，去获取所有查询时间比较长的sql语句。
>2.其次【查看执行计划】查看有问题的sql的执行计划。
>3.最后可以使用【show profile[s]】查看有问题的sql的性能使用情况。


## mysql 默认innoDB存储引擎

## 回表：根据普通索引查询到主键值，根据主键值去主键索引去寻找需要的数据。

## 索引覆盖：

## 索引下推:
```
比如说有一个组合索引(name , age)
1、如果没有使用索引下推那么执行的时候就是:先根据name把所有的数据拉取到server层，在server层对age进行过滤。
2、如果使用了索引下推那么执行的时候就是:根据name，age把对应的数据拉取到server层，取对应的数据。 

```

## 最左匹配:

## mysql索引:

>1.索引是：高效获取数据的数据结构（B+树数据结构）
>>索引包括：聚集索引，覆盖索引，组合索引，前缀索引，唯一索引等。
（索引会存磁盘，大了一定不好）

>2.优势：

```
1.可以提高数据查询的效率，降低数据库的IO成本，相当于书的目录
2.索引支持对数据进行排序。降低数据排序的成本，降低 cpu的消耗
```
>3.劣势：

```
1.索引会占据磁盘空间（磁盘空间占的越大，读取索引耗时越多）
2.索引虽然会提高查询效率，但是会降低更新表的效率（在增删改的时候就会对索引的表结构进行变更）
```

## 常用索引分类

**主键索引**效果最好 其次是 *组合索引*

>1.单列索引：
	*普通索引：mysql基本索引类型，没有限制，允许在定义索引的列中插入重复值和空值，数据更快一点。*
	*唯一索引：索引列中的值必须是唯一的 但是可以为空。*
	*主键索引：是一种特殊的唯一所有，不许有空值。*

>2.组合索引：
	*在表中的所个字段组合上创建的一个索引。*
	*最左前缀原则（最左匹配原则）*
	*建议使用组合索引，代替单个所引*



### 索引使用（待测试）

```

```


## 索引存储结构
*B树 和 B+树*
```
B树3层可以存bigint类型10亿条
```

>B树：非叶子节点和叶子节点都会存储数据
>B+树：只有叶子节点会存数据 ，非叶子节点不存数据只存指针


## 聚集索引    表数据和索引是存在一起的就交聚集索引
```
id 是主键------主键索引(有且只有一个)
name 非唯一索引 ---- 辅助索引(可以有多个)
例如：select *  from  student where id = 1 and name = '李晓钰'


(不要用特别长的字段作为主键)
(如果没有主键就会找一个唯一非空列，如果找不到就会默认创建一个隐藏列)
1.主键索引：数据就是指数据行，就是一行记录。

2.辅助索引：存的索引字段和主键值

```
## 聚集索引
**聚集索引(叶子节点存的是主键值)，聚集索引(叶子节点存的是地址值)**




## 组合索引    创建的顺序特别重要   （创建顺序的选择也是优化的目标）

>创建下面这个组合索引，相当于创建了c1,c1 c2 ,c1 c2 c3  3个索引
>
>AL RABLE 'table_name' ADD INDEX index_name('c1','c2','c3')



```

例如:AL RABLE 'table_name' ADD INDEX index_name('c1','c2','c3')       就是创建了一棵B+树 但是他相当于3棵索引树的功效

where c1 = ? and c2 = ? and c3 = ?
where c1 = ? 
where  c2 = ? and c3 = ?     -- 不走组合索引
where c2 = ? and c1 = ? and c3 = ?

```

>最左匹配原则:

```
mysql 从左往右执行，oracle 从右往左执行   知道遇到范围查询停止(< , > , between , ....)
如果创建索引的顺序是 （a,b,c,d）顺序 a = 1 and b = 2 and c > 3 and d = 4  他到了abc就不走了 因为
c是范围查询，
```

>(最左匹配   需进行测试)

>1 = 1 索引优化就抛弃了  不是很好的写法

```
	
假如：建表语句
  create table user(
	id int primary key, -- 主键
	name varchar(100),
	age int,
	sex char(1),
	address varchar(100)
  );
  
  -- 创建组合索引   
  -- 注意！:这里name属性值是varchar类型的字段长度是100，但是在创建 索引的时候name指定长度是10，
			这是使用了前缀索引这个概念。 前缀索引跟多针对字符串，假如说一个字符串特别长用他进行等值匹配
			特别不靠谱，一般情况都是用字符串的前面几个进行匹配。(具体这个长度有一个字段区分度，由区分度去选则)
  alter table user add index idx_name_age(name(10),age);

```







## 如何使用索引
### 那些情况需要创建索引

>1.主键自动创建唯一索引    **一般最好建立主键**
>2.**经常作为查询的字段 作为索引**
>3.多表关联的时候，**关联字段建为索引**
>4.**查询中统计或者分组字段**  应该创建索引
>5.**查询中排序字段**   应该创建索引




### 哪些情况不需要创建索引

>1.表记录太少  加索引浪费内存
>2.经常增删改
>3.频繁更新的字段
>4.where 条件不常用的字段



## 查看执行计划
*在我们查询语句的前面加上 ***explain***  他会出来执行计划
```

例如： explain select * from user;

```

### 查询出来的计划的参数字段：
>id:			关联查询会用到多个表，多个表是有顺序的。顺序用id来标识
>select_type:	每一个表的查询类型。(子查询呢，还是联合查询呢，还是.......)
>table：		执行的时候走的那个表
>partitions：	匹配分区
>type:			连接类型
>possible_keys:	查询中可能用到的索引
>key：			本次查询中所用到的索引
>ref：			连接的时候用那个字段进行连接的
>rows：			显示一共扫描多少行
>filtered：		表示此次查询条件过滤数据的百分比
>extra：		前面的信息体现不出来的都会在这个里面体现出来



#### 参数字段：重点
>select_type

>type:显示的是单位查询连接类型或者是显示类型 访问性能依次是 从好--差：system --> const --> eq_ref --> ref --> fulltext --> ref_or_null --> unique_subquery --> index_subquery --> range --> index_merge --> index --> ALL
>>(*除了ALL其它type类型 都可以用到索引)
>>(*index_merge之外，其它的type类型只可以用到一个索引)

>system:表中只有一行数据或者是空表
>const：使用唯一或主键索引的时候，并且长度的值是一个常量。select * from user where id = 1 ; id 是主键，id类型是int的长度固定就是4.
>eq_ref:针对唯一索引
>ref:针对非唯一索引
>range:使用>,<,null,between,in,like 后模糊 等运算符的查询
>index：(跟where没啥关系，更多的就是对结果的索引覆盖)查询的数据没有进行条件搜索，是在索引树上直接取的。 比如：select sex from uesr; sex 是非唯一索引
>all:全表扫描，就是主键索引里面所有的表数据

>extra：
>>using index : 用到了索引覆盖
>>using index condition : 表示使用了索引下推
>>using where ：





```
有索引的都会在innodb存储引擎进行过滤
其次剩下的
去mysql server层进行

在mysql 5.6版本之后ICP 索引下推

```

## 索引失效

>1.最好是全值
>2.最左前缀法则
>3.不要在索引上做任何操作(计算，函数，类型转换) 会导致索引失效
>4.索引范围右边的列用不到
>5.尽量使用覆盖索引(只查询所有的列)，减少select *
>6.!= 或者 <> 无法使用索引
>7.is null ,is not null 无法使用索引
>8.like  %开头会变成全表扫描索引失效。(但是索引覆盖的情况他是会走索引的)
>9.字符串不加单引号 索引失效
>10.少用or，用or连接索引会失效





## 数据量大   分区 分表 分库(待学习)
```

```

## 性能优化

>1、服务器层面的优化
>>设置足够大的innodb_buffer_pool_size(设置缓存池的大小)将数据读取到内存中。 innodb_buffer_pool_size设置总内存大小的3/4或者4/5.
>>怎样确定innodb_buffer_pool_size足够大，数据是从内存读取而不是硬盘？ show global status like 'innodb_buffer_pool_pages_%';

>2、内存预热


>3、降低磁盘写入次数
>>对于生产环境来说，很多日志不需要开启，比如:通用查询日志，慢查询日志，错误日志
>>使用足够量打的写入缓存：innodb_log_file_size 推荐innodb_log_file_size 设置为  1/4 * innodb_log_file_size

>>设置合适的innodb_flush_log_at_trx_commit,和日志落盘有关
>4、提高磁盘读写
>>ssd硬盘，虚考虑成本






